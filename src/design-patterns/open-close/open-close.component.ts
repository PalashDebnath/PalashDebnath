import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'profile-open-close',
  templateUrl: './open-close.component.html',
  styleUrls: ['./open-close.component.scss']
})
export class OpenCloseComponent implements OnInit {
  impFirst: string[] = ['namespace DesignPatterns;', '', 'public enum Colour { Red, Blue, Green }', '', 'public enum Size { Small, Medium, Large, ExtraLarge }', '', '// Created Product class which will hold product data.', 'public class Product', '{', '  public string Name { get; private set; }', '  public Size Size { get; private set; }', '  public Colour Colour { get; private set; }', '  public Product(string name, Size size, Colour colour)', '  {', '    Name = name;', '    Size = size;', '    Colour = colour;', '  }', '  public override string ToString()', '  {', '    return $"Name: {Name}, Size: {Size}, Colour: {Colour}";', '  }', '}', '', '// Created ProductFilter class which will take a list of product and filter out a subset of product.', 'public class ProductFilter', '{', '  public static IEnumerable<Product> BySize(IEnumerable<Product> products, Size size)', '  {', '    foreach (Product product in products)', '    {', '      if (product.Size == size) yield return product;', '    }', '  }', '}', '', 'public class Program', '{', '  public static void Main(string[] args)', '  {', '    var products = new List<Product>();', '    products.Add(new Product("Apple", Size.Small, Colour.Green));', '    products.Add(new Product("Tree", Size.ExtraLarge, Colour.Green));', '    products.Add(new Product("Pumpkin", Size.Large, Colour.Red));', '    products.Add(new Product("Broccoli", Size.Large, Colour.Green));', '    products.Add(new Product("Cucumber", Size.Medium, Colour.Green));', '', '    var filteredProducts = ProductFilter.BySize(products, Size.Large);', '    foreach (var product in filteredProducts)', '    {', '        Console.WriteLine(product);', '    }', '  }', '}', '', '// Now consider ProductFilter class has to also support filtration on colour in future', '// To fulfil the requirement we have to go back to ProductFilter class and create a new function (method) to support colour', '// filtration. To do so we have to modify the implementation of ProductFilter, Which clearly violate the Open Close Principle(OCP).', '// Let see how can we do better on our second implementation to adhere with the principle.'];
  impSecond: string[] = ['namespace DesignPatterns;', '', 'public enum Colour { Red, Blue, Green }', '', 'public enum Size { Small, Medium, Large, ExtraLarge }', '', '// Created Product class which will hold product data.', 'public class Product', '{', '  public string Name { get; private set; }', '  public Size Size { get; private set; }', '  public Colour Colour { get; private set; }', '  public Product(string name, Size size, Colour colour)', '  {', '    Name = name;', '    Size = size;', '    Colour = colour;', '  }', '  public override string ToString()', '  {', '    return $"Name: {Name}, Size: {Size}, Colour: {Colour}";', '  }', '}', '', '// Created IRule interface. Which will be implemented by any new rule.', 'public interface IRule<T>', '{', '  bool IsSatisfied(T t);', '}', '', '//Created IFilter interface. Which will be implemented by any new Filter.', 'public interface IFilter<T>', '{', '  IEnumerable<T> Process(IEnumerable<T> records, IRule<T> rule);', '}', '', '//Created ColourRule class and implemented IRule interface to filter records by color. ', 'public class ColourRule : IRule<Product>', '{', '  public Colour Colour { get; private set; }', '  public ColourRule(Colour colour) { Colour = colour; }', '  public bool IsSatisfied(Product product) => product.Colour == Colour;', '}', '', '//Created SizeRule class and implemented IRule interface to filter records by size. ', 'public class SizeRule : IRule<Product>', '{', '  public Size Size { get; private set; }', '  public SizeRule(Size size) { Size = size; }', '  public bool IsSatisfied(Product product) => product.Size == Size;', '}', '', '// Modified ProductFilter class to implement IFilter interface.', 'public class ProductFilter : IFilter<Product>', '{', '  public IEnumerable<Product> Process(IEnumerable<Product> products, IRule<Product> rule)', '  {', '    foreach (var product in products)', '    {', '      if (rule.IsSatisfied(product)) yield return product;', '    }', '  }', '}', '', 'public class Program', '{', '  public static void Main(string[] args)', '  {', '    var products = new List<Product>();', '    products.Add(new Product("Apple", Size.Small, Colour.Green));', '    products.Add(new Product("Tree", Size.ExtraLarge, Colour.Green));', '    products.Add(new Product("Pumpkin", Size.Large, Colour.Red));', '    products.Add(new Product("Broccoli", Size.Large, Colour.Green));', '    products.Add(new Product("Cucumber", Size.Medium, Colour.Green));', '', '    var rule = new ColourRule(Colour.Red);', '    var filter = new ProductFilter();', '    foreach (var product in filter.Process(products, rule))', '    {', '      Console.WriteLine(product);', '    }', '  }', '}', '', '// If we check the solution now, to support any new filtration, we do not need to modify the ProductFilter class anymore. We just have to', '// introduce a new rule and pass it into the ProductFilter class as Parameter.'];
  impThird: string[] = ['enum Colour { Red, Blue, Green }', 'enum Size { Small, Medium, Large, ExtraLarge }', '', '// Created Product class which will hold product data.', 'class Product', '{', '  public name: string | undefined;', '  public size: Size | undefined;', '  public colour: Colour | undefined;', '  constructor(name: string, size: Size, colour: Colour)', '  {', '      this.name = name;', '      this.size = size;', '      this.colour = colour;', '  }', '}', '', '// Created ProductFilter class which will take a list of product and filter out a subset of product.', 'class ProductFilter', '{', '  public static BySize(products: Product[], size: Size): Product[]', '  {', '    return products.filter(product => product.size === size).slice();', '  }', '}', '', 'var products: Product[] = [', '  new Product("Apple", Size.Small, Colour.Red),', '  new Product("Apple", Size.Small, Colour.Green),', '  new Product("Tree", Size.ExtraLarge, Colour.Green),', '  new Product("Pumpkin", Size.Large, Colour.Red),', '  new Product("Broccoli", Size.Large, Colour.Green),', '  new Product("Cucumber", Size.Medium, Colour.Green)', '];', '', 'var filteredProducts = ProductFilter.BySize(products, Size.Large);', 'filteredProducts.forEach(product => console.log(product));', '', '// Now consider ProductFilter class has to also support filtration on colour in future', '// To fulfil the requirement we have to go back to ProductFilter class and create a new function (method) to support colour', '// filtration. To do so we have to modify the implementation of ProductFilter, Which clearly violate the Open Close Principle(OCP).', '// Let see how can we do better on our second implementation to adhere with the principle.'];
  impFourth: string[] = ['enum Colour { Red, Blue, Green }', 'enum Size { Small, Medium, Large, ExtraLarge }', '', '// Created Product class which will hold product data.', 'class Product', '{', '  public name: string | undefined;', '  public size: Size | undefined;', '  public colour: Colour | undefined;', '  constructor(name: string, size: Size, colour: Colour)', '  {', '      this.name = name;', '      this.size = size;', '      this.colour = colour;', '  }', '}', '', '// Created IRule interface. Which will be implemented by any new rule.', 'interface IRule<T>', '{', '  IsSatisfied(t: T): boolean;', '}', '', '//Created IFilter interface. Which will be implemented by any new Filter.', 'interface IFilter<T>', '{', '  Process(records: T[], rule: IRule<T>): T[];', '}', '', '//Created ColourRule class and implemented IRule interface to filter records by color.', 'class ColourRule implements IRule<Product>', '{', '  public colour: Colour | undefined;', '  constructor(colour: Colour) { this.colour = colour; }', '  IsSatisfied(product: Product): boolean { return product.colour === this.colour; }', '}', '', '//Created SizeRule class and implemented IRule interface to filter records by size.', 'class SizeRule implements IRule<Product>', '{', '  public size: Size | undefined;', '  constructor(size: Size) { this.size = size; }', '  IsSatisfied(product: Product): boolean { return product.size === this.size; }', '}', '', '// Modified ProductFilter class to implement IFilter interface.', 'class ProductFilter implements IFilter<Product>', '{', '  Process(products: Product[], rule: IRule<Product>): Product[]', '  {', '    return products.filter(product => rule.IsSatisfied(product)).slice();', '  }', '}', '', 'var products: Product[] = [', '  new Product("Apple", Size.Small, Colour.Red),', '  new Product("Apple", Size.Small, Colour.Green),', '  new Product("Pumpkin", Size.Large, Colour.Red),', '  new Product("Broccoli", Size.Large, Colour.Green),', '  new Product("Tree", Size.ExtraLarge, Colour.Green),', '  new Product("Cucumber", Size.Medium, Colour.Green)', '];', '', 'var rule = new ColourRule(Colour.Red);', 'var productFilter = new ProductFilter();', 'var filteredProducts = productFilter.Process(products, rule);', 'filteredProducts.forEach(product => console.log(product));', '', '// If we check the solution now, to support any new filtration, we do not need to modify the ProductFilter class anymore. We just have to', '// introduce a new rule and pass it into the ProductFilter class as Parameter.'];

  constructor() { }

  ngOnInit(): void { }
}
