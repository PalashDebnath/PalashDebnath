import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'profile-liskov-substitution',
  templateUrl: './liskov-substitution.component.html',
  styleUrls: ['./liskov-substitution.component.scss']
})
export class LiskovSubstitutionComponent implements OnInit {
  impFirst: string[] = ['namespace DesignPatterns;', '', '// Created SumCalculator base class', 'public class SumCalculator', '{', 'protected readonly int[] numbers;', 'public SumCalculator(int[] numbers) { this.numbers = numbers; }', 'public virtual int Calculate() { return numbers.Sum(); }', '}', '', '// Created EvenSumCalculator derived class', 'public class EvenSumCalculator : SumCalculator', '{', 'public EvenSumCalculator(int[] numbers) : base(numbers) { }', 'public override int Calculate() { return numbers.Where(number => number % 2 == 0).Sum(); }', '}', '', 'public class Program', '{', 'public static void Main(string[] args)', '  {', 'var numbers = new int[] { 1, 2, 3, 4, 5, 6, 7 };', '', 'SumCalculator sumCalculator = new SumCalculator(numbers);', 'Console.WriteLine($"Sum of all the numbers: {sumCalculator.Calculate()}");', '// Output: Sum of all the numbers: 28', '', 'EvenSumCalculator evenSumCalculator = new EvenSumCalculator(numbers);', 'Console.WriteLine($"Sum of all the even numbers: {evenSumCalculator.Calculate()}");', '//Output: Sum of all the even numbers: 12', '', 'SumCalculator calculator = new EvenSumCalculator(numbers);', 'Console.WriteLine($"Sum of all the numbers: {calculator.Calculate()}");', '//Output: Sum of all the numbers: 12', '  }', '}', '', '// Let walk through our outputs.', '// First we created a SumCalculator object store it in a SumCalculator type variable and called the Calculate method, we got output as 28.', '// Second we created a EvenSumCalculator object store it in a EvenSumCalculator type variable and called the Calculate method, we got output as 12.', '// Third we created a EvenSumCalculator object store it in a SumCalculator type variable and called the Calculate method, we got output as 12.', '// In first and second cases we got exact result as we intended but on the third occasion the behaviour of the Calculate method changed. As we have', '// substituted a derived class (EvenSumCalculator) object into a base class (SumCalculator) variable, as per Liskov Substitution Principle it should', '// not change the behaviour of base class (SumCalculator) Calculate method. In this implementation as we override the base class (SumCalculator) Calculator', '// method in derived class (EvenSumCalculator), the program calls derived class Calculator method. Lets try to improve our solution in next implementation.'];
  impSecond: string[] = ['namespace DesignPatterns;', '', '//Created Calculator abstract base class', 'public abstract class Calculator', '{', 'protected readonly int[] numbers;', 'public Calculator(int[] numbers) { this.numbers = numbers; }', '', 'public abstract int Calculate();', '}', '', '// Created Sum derived class', 'public class Sum : Calculator', '{', 'public Sum(int[] numbers) : base(numbers) { }', 'public override int Calculate() => numbers.Sum();', '}', '', '// Created EvenSum derived class', 'public class EvenSum : Calculator', '{', 'public EvenSum(int[] numbers) : base(numbers) { }', 'public override int Calculate() => numbers.Where(number => number % 2 == 0).Sum();', '}', '', 'public class Program', '{', 'public static void Main(string[] args)', '  {', 'var numbers = new int[] { 1, 2, 3, 4, 5, 6, 7 };', '', 'Calculator sum = new Sum(numbers);', 'Console.WriteLine($"Sum of all the numbers: {sum.Calculate()}");', '// Output: Sum of all the numbers: 28', '', 'sum = new EvenSum(numbers);', 'Console.WriteLine($"Sum of all the even numbers: {sum.Calculate()}");', '// Output: Sum of all the even numbers: 12', '  }', '}', '', '// Let walk through our outputs again.', '// In this solution we created two different objects of our derived classes (Sum & EvenSum) and one base class (Calculator) variable.', '// One after another we substituted the derived class objects into the base class variable and we got back the intended outputs.', '// Now in this case derived class do not change the behaviour of the base class Calculate method, instead it gives a behaviour to', '// the base class Calculator method by overriding. Hence the behaviour of the base and derived class Calculate methods are same.'];
  impThird: string[] = ['// Created SumCalculator base class', 'class SumCalculator', '{', 'public readonly numbers: number[];', 'constructor(numbers: number[]) { this.numbers = numbers }', 'public Calculate(): number', '{', 'let sum: number = 0;', 'this.numbers.forEach(n => { sum = sum + n; });', 'return sum;', '} ', '}', '', '// Created EvenSumCalculator derived class', 'class EvenSumCalculator extends SumCalculator', '{', 'constructor(numbers: number[]) { super(numbers); }', 'public override Calculate(): number', '{', 'let sum: number = 0;', 'this.numbers.filter(n => n % 2 === 0).forEach(n => { sum = sum + n; });', 'return sum;    ', '}', '}', '', 'var numbers: number[] = [ 1, 2, 3, 4, 5, 6, 7 ];', 'var sumCalculator: SumCalculator = new SumCalculator(numbers);', 'console.log(`Sum of all numbers: ${sumCalculator.Calculate()}`);', '// Output: Sum of all the numbers: 28', '', 'var evenSumCalculator: EvenSumCalculator = new EvenSumCalculator(numbers);', 'console.log(`Sum of all even numbers: ${evenSumCalculator.Calculate()}`);', '// Output: Sum of all the even numbers: 12', '', 'sumCalculator = new EvenSumCalculator(numbers);', 'console.log(`Sum of all numbers: ${sumCalculator.Calculate()}`);', '// Output: Sum of all the numbers: 12', '', '// Let walk through our outputs.', '// First we created a SumCalculator object store it in a SumCalculator type variable and called the Calculate method, we got output as 28.', '// Second we created a EvenSumCalculator object store it in a EvenSumCalculator type variable and called the Calculate method, we got output as 12.', '// Third we created a EvenSumCalculator object store it in a SumCalculator type variable and called the Calculate method, we got output as 12.', '// In first and second cases we got exact result as we intended but on the third occasion the behaviour of the Calculate method changed. As we have', '// substituted a derived class (EvenSumCalculator) object into a base class (SumCalculator) variable, as per Liskov Substitution Principle it should', '// not change the behaviour of base class (SumCalculator) Calculate method. In this implementation as we override the base class (SumCalculator) Calculator', '// method in derived class (EvenSumCalculator), the program calls derived class Calculator method. Lets try to improve our solution in next implementation.'];
  impFourth: string[] = ['// Created Calculator base class', 'abstract class Calculator', '{', 'protected readonly numbers: number[];', 'constructor(numbers: number[]) { this.numbers = numbers; }', 'public abstract Calculate(): number;', '}', '', '// Created Sum derived class', 'class Sum extends Calculator', '{', 'constructor(numbers: number[]) { super(numbers) }', 'public Calculate(): number', '{', 'let sum: number = 0;', 'this.numbers.forEach(n => { sum = sum + n; });', 'return sum;', '} ', '}', '', '// Created EvenSum derived class', 'class EvenSumCalculator extends Calculator', '{', 'constructor(numbers: number[]) { super(numbers); }', 'public override Calculate(): number', '{', 'let sum: number = 0;', 'this.numbers.filter(n => n % 2 === 0).forEach(n => { sum = sum + n; });', 'return sum;    ', '}', '}', '', 'var numbers: number[] = [ 1, 2, 3, 4, 5, 6, 7 ];', 'var sum: Calculator = new Sum(numbers);', 'console.log(`Sum of all numbers: ${sum.Calculate()}`);', '// Output: Sum of all the numbers: 28', '', 'sum = new EvenSumCalculator(numbers);', 'console.log(`Sum of all numbers: ${sum.Calculate()}`);', '// Output: Sum of all the numbers: 12', '', '// Let walk through our outputs again.', '// In this solution we created two different objects of our derived classes (Sum & EvenSum) and one base class (Calculator) variable.', '// One after another we substituted the derived class objects into the base class variable and we got back the intended outputs.', '// Now in this case derived class do not change the behaviour of the base class Calculate method, instead it gives a behaviour to', '// the base class Calculator method by overriding. Hence the behaviour of the base and derived class Calculate methods are same.'];

  constructor() { }

  ngOnInit(): void { }
}