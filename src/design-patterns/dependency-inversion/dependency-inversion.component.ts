import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'profile-dependency-inversion',
  templateUrl: './dependency-inversion.component.html',
  styleUrls: ['./dependency-inversion.component.scss']
})
export class DependencyInversionComponent implements OnInit {
  impFirst: string[] = ['namespace DesignPatterns;', '', '// We use in-memory storage to store the employees, rather than a real database.', '// We also implemented the lazy loading so that we do not use any memory until is it absolutely needed.', 'public static class Store', '{', 'private static Lazy<List<Employee>> employees = new Lazy<List<Employee>>();', 'public static List<Employee> Employees => employees.Value;', '}', '', 'public class Employee', '{', 'public int Id { get; private set; }', 'public int Salary { get; private set; }', 'public string LastName { get; private set; }', 'public string FirstName { get; private set; }', 'public string Department { get; private set; }', 'public Employee(string firstName, string lastName, string department, int salary)', '{', 'Salary = salary;', 'LastName = lastName;', 'FirstName = firstName;', 'Department = department;', 'Id = Store.Employees.Count + 1;', '}', 'public override string ToString() => $"Employee: {FirstName} {LastName}, Department: {Department}, Salary: ${Salary}";', '}', '', '// Created employee data access logic layer', 'public class EmployeeDAL', '{', 'public void AddEmployee(Employee employee) => Store.Employees.Add(employee);', 'public Employee FetchEmployee(int id) => Store.Employees.Where(employee => employee.Id == id).First();', '}', '', '// Created employee business logic layer', 'public class EmployeeBAL', '{', '  private readonly EmployeeDAL employeeDAL;', '  public EmployeeBAL() { employeeDAL = new EmployeeDAL(); }', '  public Employee FetchEmployee(int id) => employeeDAL.FetchEmployee(id);', '  public void RegisterEmployee(Employee employee) => employeeDAL.AddEmployee(employee);', '}', '', 'public class Program', '{', 'public static void Main(string[] args)', '{', 'var employee = new Employee("Palash", "Debnath", "Information Technology", 100000);', 'var employeeBAL = new EmployeeBAL();', 'employeeBAL.RegisterEmployee(employee);', 'Console.WriteLine(employeeBAL.FetchEmployee(1));', '}', '}', '', '// Let walk through the solution. In our solution we have a data layer (EmployeeDAL) and business layer (EmployeeBAL). Now in respect', '// to that EmployeeBAL is high level class which directly depend on the low level class EmployeeDAL. These two classes are kind of', '// tightly coupled with each other. As per Dependency Inversion Principle (DIP) high level class and low level should depend on abstraction', '// rather then direct implementation. Hence we are violating the Dependency Inversion Principle (DIP). Let see how we can do better in', '// next implementation.'];
  impSecond: string[] = ['namespace DesignPatterns;', '', '// We use in-memory storage to store the employees, rather than a real database.', '// We also implemented the lazy loading so that we do not use any memory until is it absolutely needed.', 'public static class Store', '{', 'private static Lazy<List<Employee>> employees = new Lazy<List<Employee>>();', 'public static List<Employee> Employees => employees.Value;', '}', '', 'public class Employee', '{', 'public int Id { get; private set; }', 'public int Salary { get; private set; }', 'public string LastName { get; private set; }', 'public string FirstName { get; private set; }', 'public string Department { get; private set; }', 'public Employee(string firstName, string lastName, string department, int salary)', '{', 'Salary = salary;', 'LastName = lastName;', 'FirstName = firstName;', 'Department = department;', 'Id = Store.Employees.Count + 1;', '}', 'public override string ToString() => $"Employee: {FirstName} {LastName}, Department: {Department}, Salary: ${Salary}";', '}', '', '// Created IEmployeeDAL interface', 'public interface IEmployeeDAL', '{', 'void AddEmployee(Employee employee);', 'Employee FetchEmployee(int id);', '}', '', '// Modified employee data accesss logic layer to implement IEmployeeDAL interface', 'public class EmployeeDAL : IEmployeeDAL', '{', 'public void AddEmployee(Employee employee) => Store.Employees.Add(employee);', 'public Employee FetchEmployee(int id) => Store.Employees.Where(employee => employee.Id == id).First();', '}', '', '// Modified employee business logic layer to reference the IEmployeeDAL interface', 'public class EmployeeBAL', '{', '  private readonly IEmployeeDAL employeeDAL;', '  public EmployeeBAL() { employeeDAL = new EmployeeDAL(); }', '  public Employee FetchEmployee(int id) => employeeDAL.FetchEmployee(id);', '  public void RegisterEmployee(Employee employee) => employeeDAL.AddEmployee(employee);', '}', '', 'public class Program', '{', 'public static void Main(string[] args)', '{', 'var employee = new Employee("Palash", "Debnath", "Information Technology", 100000);', 'var employeeBAL = new EmployeeBAL();', 'employeeBAL.RegisterEmployee(employee);', 'Console.WriteLine(employeeBAL.FetchEmployee(1));', '}', '}'];
  impThird: string[] = ['// We use in-memory storage to store the employees, rather than a real database.', 'class Store', '{', 'static Employees: Employee[] = [];', '}', '', 'class Employee', '{', 'public id: number;', 'public salary: number;', 'public lastName: string;', 'public firstName: string;', 'public department: string;', 'constructor(firstName: string, lastName: string, department: string, salary: number)', '{', 'this.salary = salary;', 'this.lastName = lastName;', 'this.firstName = firstName;', 'this.department = department;', 'this.id = Store.Employees.length + 1;', '}', '}', '', '// Created employee data access logic layer', 'class EmployeeDAL', '{', 'public AddEmployee(employee: Employee): void { Store.Employees.push(employee); }', 'public FetchEmployee(id: number): Employee | undefined { return Store.Employees.find(employee => employee.id == id); }', '}', '', '// Created employee business logic layer', 'class EmployeeBAL', '{', '  private readonly employeeDAL: EmployeeDAL;', '  public constructor() { this.employeeDAL = new EmployeeDAL(); }', '  public FetchEmployee(id: number): Employee | undefined { return this.employeeDAL.FetchEmployee(id); }', '  public RegisterEmployee(employee: Employee): void { this.employeeDAL.AddEmployee(employee); }', '}', '', 'var employee = new Employee("Palash", "Debnath", "Information Technology", 100000);', 'var employeeBAL = new EmployeeBAL();', 'employeeBAL.RegisterEmployee(employee);', 'console.log(employeeBAL.FetchEmployee(1));', '', '// Let walk through the solution. In our solution we have a data layer (EmployeeDAL) and business layer (EmployeeBAL). Now in respect', '// to that EmployeeBAL is high level class which directly depend on the low level class EmployeeDAL. These two classes are kind of', '// tightly coupled with each other. As per Dependency Inversion Principle (DIP) high level class and low level should depend on abstraction', '// rather then direct implementation. Hence we are violating the Dependency Inversion Principle (DIP). Let see how we can do better in', '// next implementation.'];
  impFourth: string[] = ['// We use in-memory storage to store the employees, rather than a real database.', 'class Store', '{', 'static Employees: Employee[] = [];', '}', '', 'class Employee', '{', 'public id: number;', 'public salary: number;', 'public lastName: string;', 'public firstName: string;', 'public department: string;', 'constructor(firstName: string, lastName: string, department: string, salary: number)', '{', 'this.salary = salary;', 'this.lastName = lastName;', 'this.firstName = firstName;', 'this.department = department;', 'this.id = Store.Employees.length + 1;', '}', '}', '', '// Created IEmployeeDAL interface', 'interface IEmployeeDAL', '{', 'AddEmployee(employee: Employee): void;', 'FetchEmployee(id: number): Employee | undefined;', '}', '', '// Modified employee data accesss logic layer to implement IEmployeeDAL interface', 'class EmployeeDAL implements IEmployeeDAL', '{', 'public AddEmployee(employee: Employee): void { Store.Employees.push(employee); }', 'public FetchEmployee(id: number): Employee | undefined { return Store.Employees.find(employee => employee.id == id); }', '}', '', '// Modified employee business logic layer to reference the IEmployeeDAL interface', 'class EmployeeBAL', '{', '  private readonly employeeDAL: EmployeeDAL;', '  public constructor() { this.employeeDAL = new EmployeeDAL(); }', '  public FetchEmployee(id: number): Employee | undefined { return this.employeeDAL.FetchEmployee(id); }', '  public RegisterEmployee(employee: Employee): void { this.employeeDAL.AddEmployee(employee); }', '}', '', 'var employee = new Employee("Palash", "Debnath", "Information Technology", 100000);', 'var employeeBAL = new EmployeeBAL();', 'employeeBAL.RegisterEmployee(employee);', 'console.log(employeeBAL.FetchEmployee(1));'];

  constructor() { }

  ngOnInit(): void { }
}